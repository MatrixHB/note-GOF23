GOF23

创建型模式：用于创建对象

单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式

### 单例模式

**应用场景**：windows任务管理器、读取配置文件的类、网站的计数器（便于同步）、应用程序的日志（便于追加）、数据库连接池、Spring容器中的bean、servlet、controller等

**优点**：当一个对象的产生需要读取配置、注入依赖等较多资源时，能减少性能开销

饿汉式：调用效率高、不能延迟加载

懒汉式：延迟加载，即真正用的时候才创建实例，为避免创建多个实例，需要同步（synchronized）

双重检查锁实现方式：仅在第一次加载时需要加同步锁

**静态内部类实现方式** （兼具线程安全、调用效率高、懒加载的优点）

```java
//只有真正调用getInstancce()时才会加载静态内部类，而加载类时是静态安全的
public class Singleton{
    private Singleton(){}   //构造方法私有化
    private static class SingletonInstance{       //静态内部类
        private static final Singleton instance = new Singleton();
    }
    public static Singleton getInstance(){        //获取单例对象
        return SingletonInstance.instance;
    }
}
```

**spring源码中的单例模式** ：Spring的依赖注入（不是FactoryBean的Bean）都是发生在 **AbstractBeanFactory** 的 **getBean** 里。 **getBean** 的 **doGetBean** 方法调用 **getSingleton** 进行bean的创建。lazy-init方式(lazy-init=“true”)，在用户向容器第一次索要bean时进行调用；非lazy-init方式(lazy-init=“false”)，在容器初始化时候进行调用。

```java
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
    synchronized (this.singletonObjects) {
        //检查缓存中是否有已实例化的bean
        Object singletonObject = this.singletonObjects.get(beanName);
        if (singletonObject == null) {
            ...
            //下面这句话是为了标记该bean正在被创建
            beforeSingletonCreation(beanName);
            boolean newSingleton = false;
            ...
            try {
                //实例化bean
                singletonObject = singletonFactory.getObject();
                newSingleton = true;
            }
            catch (IllegalStateException ex) {
                ...
            }
            catch (BeanCreationException ex) {
                ...
            }
            finally {
                //清除该bean正在被创建的标记
                afterSingletonCreation(beanName);
            }
            if (newSingleton) {
                //将已实例化的bean加入到缓存singletonObjects中
                addSingleton(beanName, singletonObject);
            }
        }
        return singletonObject;
    }
}
```

 **p.s. spring获取单例bean时对循环依赖的解决**

````java
//this.singletonObjects是一个concurrentHashMap作为缓存，获取Bean实例时先从缓存中拿。

//isSingletonCurrentlyInCreation和this.earlySingletonObjects是为了解决Bean循环依赖的问题。比如创建bean a的时候发现bean a引用了bean b，此时会去创建bean b，但又发现bean b引用了bean c，此时会去创建bean c，但又发现bean c引用了bean a，这三个bean就形成了一个环（死锁）

//如果缓存中拿不到，但该bean正在创建过程中（isSingletonCurrentlyInCreation），说明出现了循环依赖，则尝试从singletonFactories中获取。为了解决循环依赖的问题，spring采取了一种机制，将创建的bean实例“提早”暴露加入到singletonFactories中，一旦下一个bean创建的时候需要依赖上个bean，则直接使用ObjectFactory来获取bean。提前暴露bean实例的“时机”是在bean实例创建（调用构造方法）之后，初始化bean实例（属性注入）之前。

//在从singletonFactories获取bean后，会将其存储到earlySingletonObjects缓存中，然后从singletonFactories移除该bean，之后在要获取该bean就直接从earlySingletonObjects获取。

//allowEarlyReference：允许Bean提前暴露

//singletonObjects和earlySingletonObjects的区别主要在于earlySingletonObjects是为了解决循环依赖设置的，储存的是提前暴露的bean name –> bean instance，而singletonObjects存储的是完全实例化的bean name –> bean instance。

protected Object getSingleton(String beanName, boolean allowEarlyReference) {
    Object singletonObject = this.singletonObjects.get(beanName);
    if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
        synchronized (this.singletonObjects) {
            singletonObject = this.earlySingletonObjects.get(beanName);
            if (singletonObject == null && allowEarlyReference) {
                ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
                if (singletonFactory != null) {
                    singletonObject = singletonFactory.getObject();
                    this.earlySingletonObjects.put(beanName, singletonObject);
                    this.singletonFactories.remove(beanName);
                }
            }
        }
    }
    return singletonObject;
}
````

